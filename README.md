# 一、常见问题

* 开发人员热衷于技术并通过技术手段解决问题，而不是深入思考与设计，这会导致他们孜孜不倦地追逐技术上的新潮流；
* 过于重视数据库、数据流。大多数解决方案的讨论都是围绕数据流、数据库、数据模型来开展的，而不是聚焦业务流程和运作方式；
* 开发人员没有足够重视根据业务目标命名的对象和操作，这导致他们交付的软件和业务模型之间有较大的分歧；
* 业务干系人常常浪费大量时间闭门造车，以实现各种无人问津的需求，或者只有一小部分能开版本吸收；
* 开发人员使用“任务看板”，而非考虑周祥的设计导致他们造出了一个个“大泥球”；
* 在用户界面的持久层组件中构建业务逻辑或在业务逻辑中执行持久化操作；
* 数据库查询会时常出现中断、延迟、死锁等问题，阻碍用户执行时间敏感型的业务操作；
* 项目中存在错误的抽象级别，开发人员试图借助过度概括的方案瞒足所有当下以及臆想出来的未来需求，而不是解决实际而又具体的业务诉求；
* 存在紧耦合服务群，当一个服务执行操作时，该服务直接调用另一个服务并引发一个对待操作；
* 业务逻辑、权限、事务等等一系列的事情等着 Service 层去做，如此产生了大量的依赖和循环依赖，当业务复杂度上升时，直接导致了服务层所含的代码过于庞大和复杂、测试成本直线上升，并且各个 Service 的逻辑散落在各处，维护的成本也非常大；
* 开发与产品之间的「沟通」不能保持一致，双方对于同一事物的「表达和理解」有很大的区别。产品看到的是实际的「业务场景」，而开发则更关注背后的「实现逻辑」。

# 二、CRUD 的各种问题
数据库就像是现代软件开发的一剂灵丹妙药，不仅提供可靠、快速、大容量的存储服务，还支持强大的事务管理机制，满足了大部分场景中对数据的一致性需求。数据库如此的强大，以至于我们从接触软件开发开始就一直使用「CRUD」的模式进行开发。我们的「潜意识」中就形成了「以数据为中心」的开发模式。

## 问题一：面向对象和数据库天然阻抗

* **对象和关系数据库累赘转换** - 在一个面向对象的系统中，对象是数据的承载方式，每一个 DAO 对象都对应着关系数据库中的一条数据。但通常视图层只显示完整实体对象的一小部分数据，在绝大多数应用中，通过创建一个新的专用的「数据传输对象」来承载视图层所需数据。于是我们看到各种冗余、繁多的「传输层对象」，随着时间的推移，系统中堆积的「传输层对象」越来越多，不仅增加了系统的「复杂度」，而且还降低了我们的「开发效率」。

* **继承关系的尴尬实现** - 继承是面向对象的一个重要特性，而关系数据库却难以复现对象世界中的继承关系。

* **类的复杂关系实现** - 使用外键、主键或使用一个中间关系表来表达关系。

## 问题二：是一种数据模型，与业务脱节

「Entity层」只是数据库表结构的一种映射用于承载数据；「DAO层」只是封装了对「Entity层」的增删改查；「Controller层」只是简单的把地址和对应「Service层」的对应方法做了关联返回结果给「视图层」；而「Service层」则大部分工作也只是在做一些「查询」、「拼接数据」的工作。这样的系统是声称套上了业务的外衣，而实则几乎无法保证业务逻辑的正确性、完整性。

## 问题三：CRUD 缺少意图

当系统的「复杂度」上升的时候，「CRUD」可能会缺少一件事：意图。例如：

我们想要改变一个 Customer 的地址，在「CRUD」体系中，我们只需要发出更新语句就能实现。但是我们无法弄清楚这种变化是由不正确的操作引起的，还是客户真的转移到了另一个城市。也许我们有一个业务场景，需要再重新定位时触发对外部系统的通知。在这种情况下，「CRUD」显得有所缺失。

## 问题四：被人诟病的「U」

并且现在由于「REST」的流行，大多数的「API」都是围绕「资源模型」来进行「CRUD」操作的，这样做不仅确实极大地方便了开发人员的工作，并且借由「HTTP动词」和「资源URI」结合起来有很好的可读性。

然而，我们考虑一个简单的「银行账户」资源的问题。当我们需要把账户的余额更新为想要的数量的时候，我们应该允许客户端直接调用更新方法吗？任何余额调整的动作都应该作为某种类型的交易事务被记录下来才对，例如「充值」、「取钱」，还是「转账」？另外账户是否存在？可能变更吗？等等一系列问题都可能使你的通用「U」变得臃肿难以维护。

## 问题五：提供变更历史记录的操作很复杂

「CRUD」会丢失应用程序的历史记录。例如，如果用户在一段时间内多次变更记录，我们则无法再跟踪单个更改。更糟糕的是，甚至无法确定该条目是否曾经被改变过。

当然，这可以通过为最后更新的时间戳添加字段来处理，但这只会帮助我们能够获得最新的更新。如果你对整个历史感兴趣，事情就会变得复杂：你必须从一开始就额外引入一组字段or一张新表。

这里的问题是：由于你不知道将来会询问哪些关于你数据的问题，因此你无法针对相应的情况对表做出优化。因为你收集太多或者太少的数据，似乎都存在一定问题。

## 总结

理解并抽象出业务逻辑，建立满足需求的业务模型，以此设计实现出可靠的系统，并有效地控制复杂性。

爱因斯坦说：“如果给我 1 个小时解答一道决定我生死的问题，我会花 55 分钟来弄清楚这道题到底是在问什么。一旦清楚了它到底在问什么，剩下的 5 分钟足够回答这个问题。”

# 三、DDD

「DDD」的全称是「Domain-driven Design」，即「领域驱动设计」。是由「Eric Evans」最早提出的综合软件系统分析和设计的面向对象建模方法，如今已经发展为一种针对大型复杂系统的领域建模与分析方法。

「DDD」定义了一些基本概念，然后尝试让业务和开发都能够理解这些概念名词，然后让「领域专家」（这里你可以理解为熟悉业务的人）使用这些概念名词来描述业务，而由于使用了规定的概念名词，开发就可以很好的理解领域业务，并能够按照领域业务设计的方式进行软件实现。

**<u>这就是DDD的初衷：让业务架构绑定系统架构</u>**。

<div align="center">
    <img src="./assets/ba2sa.png" width="600px" align="center"/>
    <br/>
    <span>业务架构绑定系统架构</span>
</div>

## DDD 帮助解决微服务拆分困境

使用DDD可以做到绑定业务架构和系统架构，这种绑定对于微服务来说有什么关系呢。所谓的微服务拆分困难，其实根本原因是不知道边界在什么地方。而使用DDD对业务分析的时候，首先会使用「聚合」这个概念把关联性强的业务概念划分在一个边界下，并限定「聚合」和「聚合」之间只能通过「聚合根」来访问，这是第一层边界。

然后在「聚合」基础之上根据「业务相关性」、「业务变化频率」、「组织结构」等等约束条件来定义「限界上下文」，这是第二层边界。有了这两层边界作为约束和限制，微服务的边界也就清晰了，拆分微服务也就不再困难了。

## DDD 帮助应对系统复杂性

解决复杂和大规模软件的武器可以被粗略地归为三类：「抽象」、「分治」和「知识」。

**分治：** 把问题空间分割为规模更小且易于处理的若干子问题。分割后的问题需要足够小，以便一个人单枪匹马就能够解决他们；其次，必须考虑如何将分割后的各个部分装配为整体。分割得越合理越易于理解，在装配成整体时，所需跟踪的细节也就越少。即更容易设计各部分的协作方式。评判什么是分治得好，即高内聚低耦合。

**抽象：** 使用抽象能够精简问题空间，而且问题越小越容易理解。举个例子，从北京到上海出差，可以先理解为使用交通工具前往，但不需要一开始就想清楚到底是高铁还是飞机，以及乘坐它们需要注意什么。

**知识：** 顾名思义，「DDD」可以认为是知识的一种。

「DDD」提供了这样的知识手段，让我们知道如何抽象出「限界上下文」以及如何去「分治」。

<div align="center">
    <img src="./assets/bounded-context.png" width="600px" align="center"/>
    <br/>
    <span>限界上下文与分治</span>
</div>

另外，「DDD」架构区别于传统的方式：

<div align="center">
    <img src="./assets/ddd-arch.png" width="600px" align="center"/>
    <br/>
    <span>传统架构 vs. DDD</span>
</div>

DDD」把大多数的业务逻辑都包含在了「聚合」、「实体」、「值对象」里面，简单理解也就是实现了对象自治，把之前暴露出来的一些业务操作隐藏进了「域」之中。每个不同的区域之间只能通过对外暴露的统一的聚合根来访问，这样就做了收权的操作，这样数据的定义和更改的地方就聚集在了一处，很好的解决了复杂度的问题。